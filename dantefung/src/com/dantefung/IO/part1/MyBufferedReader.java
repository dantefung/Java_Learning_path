package com.dantefung.IO.part1;

import java.io.IOException;
import java.io.Reader;

/*
 * 用Reader模拟BufferedReader的readLine()功能。
 * 
 * readLine():一次读取一行，根据换行符判断是否结束，只返回内容，不返回换行符。
 * 
 * 
 * 装饰器（Decorator）设计模式：
 * 改变对象的外壳，它改变了这个对象的行为。
 * 
 * 别名：
 * Wrapper
 * 
 * 优点：
 * 通过使用装饰器模式，可以在运行时扩充一个类的功能。
 * 
 * 意图：
 * 动态地给一个对象添加一些额外的职责。
 * 
 * 动机：
 * 有时我们希望给某个  对象  而不是  整个类  添加一些功能。
 * 
 * 该修饰类MyBufferedReader 用来包装原来的Reader
 * 
 * */
public class MyBufferedReader {
     private Reader r;//面向接口编程，聚合对象。
     
     public MyBufferedReader(Reader r)
     {
    	 this.r = r;
     }
     
     /*
      *思考： 写一个方法，返回值是一个字符串。 
      */
     public String readLine() throws IOException
     {
		
    	 /*
    	  * WHY?--WHAT？--HOW？
    	  * 
    	  *我要 返回一个字符串，我该怎么办呢？
    	  *
    	  *我们必须去看看r对象能够读取什么东西呢？
    	  *答：两个读取方法，一次读取一个字符或者一次读取一个字符数组
    	  *
    	  *那么，我们要返回一个字符串，用哪个方法比较好呢？
    	  *答：我们很容易想到字符数组比较好，但是问题来了，就是这个数组的长度是多长呢？
    	  *根本就没有拌饭定义数组的长度，你定义多长的都不合适。所以，只能选择一次读取一个字符。
    	  *
    	  *但是呢，使用这种方式的时候，我们再读取下一个字符的时候，上一个字符就丢失了，所以，我们又应该定义一个临时存储空间
    	  *把读取过来的字符存储起来。
    	  *这个用谁比较合适呢？数组，集合，字符串缓冲区三个可供选择。
    	  *
    	  *经过简单的分析，最终选择使用字符串缓冲区对象。并且使用的是StringBuilder
    	  *
    	  *StringBuilder在单线程中效率比较高。
    	  */
    	 StringBuilder sb = new StringBuilder();
    	 /*
    	  *做这个读取最麻烦的是判断结束，但是结束之前应该是一直被读取，直到-1 
    	  * 
    	  *注意：windows下的换行是 \r\n
    	  */
    	 
    	 /*
 		  *hello
 		  *world
 		  *java	
 		
 		  *104101108108111
 		  *119111114108100
 		  *1069711897
 		  */
    	 
    	 int ch = 0;
    	 while((ch = this.r.read()) != -1)
    	 {
    		 if(ch == '\r')
    		 {
    			 continue;
    		 }
    		 
    		 if(ch == '\n')
    		 {
    			 return sb.toString();
    		 }
    		 else
    		 {
    			 sb.append((char)ch);
    		 }
    	    		 
    	 }
    	 
		 //为了防止数据丢失，判断sb的长度不能大于0
		 if(sb.length() > 0)
		 {
			 return sb.toString();
		 }
		 
    	 return null;
     }
     
     /*
      * 
      * 先写一个关闭方法。
      * 
      */
     public void close() throws IOException
     {
    	 this.r.close();
     }
}
